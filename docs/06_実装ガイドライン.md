# 実装ガイドライン

## 1. 概要

本ガイドラインでは、Cursorを使用したJava開発における実装時のコーディング規約、ベストプラクティス、注意事項を説明します。

---

## 2. コーディング規約

### 2.1 命名規則

#### 2.1.1 クラス名
- PascalCaseを使用
- 名詞を使用
- 例: `UserService`, `EmployeeController`

#### 2.1.2 メソッド名
- camelCaseを使用
- 動詞で始める
- 例: `findById`, `createUser`, `updateEmployee`

#### 2.1.3 変数名
- camelCaseを使用
- 意味のある名前を使用
- 例: `userName`, `employeeList`, `departmentId`

#### 2.1.4 定数名
- UPPER_SNAKE_CASEを使用
- 例: `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE`

#### 2.1.5 パッケージ名
- 小文字のみ使用
- ドメイン名を逆順に使用
- 例: `com.company.system.controller`

### 2.2 コーディングスタイル

#### 2.2.1 インデント
- スペース4つを使用（タブは使用しない）

#### 2.2.2 改行
- 1行の長さは120文字以内
- 適切な位置で改行

#### 2.2.3 コメント
- JavaDocコメントをクラス・メソッドに記述
- 複雑なロジックには説明コメントを追加

```java
/**
 * ユーザー情報を管理するサービスクラス
 */
@Service
public class UserService {
    
    /**
     * IDでユーザーを取得します
     * 
     * @param id ユーザーID
     * @return ユーザーDTO
     * @throws ResourceNotFoundException ユーザーが見つからない場合
     */
    public UserDto findById(Long id) {
        // 実装
    }
}
```

---

## 3. レイヤー別実装ガイドライン

### 3.1 Controller層

#### 3.1.1 責務
- HTTPリクエストの受け取り
- リクエストパラメータのバリデーション
- レスポンスの返却
- **ビジネスロジックは含めない**

#### 3.1.2 実装例
```java
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    
    private final UserService userService;
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        UserDto user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    @PostMapping
    public ResponseEntity<UserDto> createUser(
            @Valid @RequestBody CreateUserRequest request) {
        UserDto createdUser = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
}
```

#### 3.1.3 ベストプラクティス
- `@RestController`を使用
- `@RequestMapping`でベースパスを定義
- `@Valid`でリクエストボディをバリデーション
- 適切なHTTPステータスコードを返却

### 3.2 Service層

#### 3.2.1 責務
- ビジネスロジックの実装
- トランザクション管理
- 他サービスとの連携
- **データベースアクセスは含めない（Repositoryに委譲）**

#### 3.2.2 実装例
```java
@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserDto findById(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("ユーザーが見つかりません"));
        return convertToDto(user);
    }
    
    public UserDto create(CreateUserRequest request) {
        // メールアドレスの重複チェック
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new DuplicateResourceException("メールアドレスが重複しています");
        }
        
        User user = new User();
        user.setName(request.getName());
        user.setEmail(request.getEmail());
        User savedUser = userRepository.save(user);
        
        return convertToDto(savedUser);
    }
    
    private UserDto convertToDto(User user) {
        // DTOへの変換ロジック
    }
}
```

#### 3.2.3 ベストプラクティス
- `@Service`アノテーションを使用
- `@Transactional`でトランザクション管理
- ビジネスルールのチェックを実装
- 例外を適切にスロー

### 3.3 Repository層

#### 3.3.1 責務
- データベースアクセス
- CRUD操作の実装
- カスタムクエリの定義

#### 3.3.2 実装例
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.deletedAt IS NULL")
    List<User> findAllActive();
    
    @Modifying
    @Query("UPDATE User u SET u.deletedAt = CURRENT_TIMESTAMP WHERE u.id = :id")
    void softDelete(@Param("id") Long id);
}
```

#### 3.3.3 ベストプラクティス
- `JpaRepository`を継承
- メソッド名でクエリを自動生成
- 複雑なクエリは`@Query`で明示的に定義
- 論理削除の場合は`deletedAt`をチェック

### 3.4 Model層（Entity）

#### 3.4.1 責務
- データベーステーブルとのマッピング
- エンティティ間のリレーション定義

#### 3.4.2 実装例
```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}
```

#### 3.4.3 ベストプラクティス
- `@Entity`アノテーションを使用
- `@Table`でテーブル名を明示
- `@Column`で制約を定義
- `@PrePersist`で作成日時の自動設定

### 3.5 DTO層

#### 3.5.1 責務
- API間のデータ転送
- エンティティの情報を必要な分だけ公開

#### 3.5.2 実装例
```java
public class UserDto {
    
    private Long id;
    private String name;
    private String email;
    private LocalDateTime createdAt;
    
    // コンストラクタ、ゲッター、セッター
}
```

#### 3.5.3 ベストプラクティス
- エンティティを直接返却しない
- 必要な情報のみを含める
- 不変オブジェクトとして設計（可能な限り）

---

## 4. 例外処理

### 4.1 カスタム例外の作成
```java
public class ResourceNotFoundException extends RuntimeException {
    
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```

### 4.2 グローバル例外ハンドラー
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException e) {
        ErrorResponse error = new ErrorResponse("ERR001", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException e) {
        ErrorResponse error = new ErrorResponse("ERR002", "バリデーションエラー");
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
}
```

---

## 5. ログ出力

### 5.1 ログレベルの使い分け
- **ERROR**: エラー発生時
- **WARN**: 警告発生時
- **INFO**: 重要な処理の開始・終了
- **DEBUG**: デバッグ情報

### 5.2 ログ出力例
```java
@Slf4j
@Service
public class UserService {
    
    public UserDto findById(Long id) {
        log.info("ユーザー取得開始: id={}", id);
        try {
            User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("ユーザーが見つかりません"));
            log.info("ユーザー取得完了: id={}", id);
            return convertToDto(user);
        } catch (Exception e) {
            log.error("ユーザー取得エラー: id={}", id, e);
            throw e;
        }
    }
}
```

---

## 6. テスト実装ガイドライン

### 6.1 単体テスト
- 1つのメソッドに対して複数のテストケースを作成
- 正常系・異常系の両方をテスト
- モックを適切に使用

### 6.2 テスト命名規則
```java
@Test
void findById_正常系_存在するIDでユーザー取得() {
    // テスト実装
}

@Test
void findById_異常系_存在しないIDでユーザー取得() {
    // テスト実装
}
```

### 6.3 テストの独立性
- 各テストは独立して実行できること
- テストデータのセットアップ・クリーンアップを適切に実施

---

## 7. Cursorでの実装時の注意点

### 7.1 コンテキストの提供
実装を依頼する際は、関連する設計書や既存コードを参照させることが重要です。

```
@docs/05_サンプルシステム設計書.md と
@src/main/java/com/company/system/model/User.java を参照して、
UserServiceを実装してください。
```

### 7.2 段階的な実装
大きな機能は小さな単位に分割して実装します。

1. まずエンティティを実装
2. 次にRepositoryを実装
3. その後Serviceを実装
4. 最後にControllerを実装

### 7.3 コードレビューの依頼
実装後、Cursorにコードレビューを依頼できます。

```
@src/main/java/com/company/system/service/UserService.java を
レビューしてください。改善点があれば指摘してください。
```

### 7.4 リファクタリングの依頼
コードの改善を依頼できます。

```
@src/main/java/com/company/system/service/UserService.java を
リファクタリングして、可読性を向上させてください。
```

---

## 8. パフォーマンス考慮事項

### 8.1 N+1問題の回避
```java
// 悪い例
List<User> users = userRepository.findAll();
for (User user : users) {
    Department department = user.getDepartment(); // N+1問題
}

// 良い例
@Query("SELECT u FROM User u JOIN FETCH u.department")
List<User> findAllWithDepartment();
```

### 8.2 ページネーションの実装
```java
Pageable pageable = PageRequest.of(page, size);
Page<User> users = userRepository.findAll(pageable);
```

### 8.3 キャッシュの活用
```java
@Cacheable("users")
public UserDto findById(Long id) {
    // 実装
}
```

---

## 9. セキュリティ考慮事項

### 9.1 SQLインジェクション対策
- JPAのクエリメソッドを使用
- `@Query`を使用する場合はパラメータ化クエリを使用

### 9.2 入力値のバリデーション
```java
public class CreateUserRequest {
    
    @NotBlank(message = "名前は必須です")
    @Size(max = 100, message = "名前は100文字以内で入力してください")
    private String name;
    
    @NotBlank(message = "メールアドレスは必須です")
    @Email(message = "メールアドレスの形式が正しくありません")
    private String email;
}
```

### 9.3 パスワードのハッシュ化
```java
@Autowired
private PasswordEncoder passwordEncoder;

public void createUser(String password) {
    String hashedPassword = passwordEncoder.encode(password);
    // 保存
}
```

---

## 10. チェックリスト

### 実装前
- [ ] 詳細設計書を確認した
- [ ] 実装方針が明確になった
- [ ] 必要な依存関係が確認できた

### 実装中
- [ ] コーディング規約に従っている
- [ ] 適切な例外処理が実装されている
- [ ] ログ出力が適切に実装されている
- [ ] JavaDocコメントが記述されている

### 実装後
- [ ] コンパイルエラーがない
- [ ] 単体テストがすべてパスしている
- [ ] コードレビューが完了している
- [ ] ドキュメントが更新されている

---

## 11. 参考資料

- [Spring Boot公式ドキュメント](https://spring.io/projects/spring-boot)
- [JUnit 5公式ドキュメント](https://junit.org/junit5/)
- [Javaコーディング規約](https://google.github.io/styleguide/javaguide.html)

